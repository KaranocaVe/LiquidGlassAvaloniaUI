// SKSL (Skia Shading Language) shader for a frosted glass effect

// uniform: Variables passed from the C# code
uniform shader content;      // The captured content behind the control, as an input texture
uniform float blurRadius;    // The blur radius; a larger value means more blur
uniform vec2 resolution;     // The size (resolution) of the control

// main is the entry point for the shader. It receives pixel coordinates (fragCoord) and returns the final color.
half4 main(vec2 fragCoord) {
    // If the blur radius is zero or negative, don't blur and return the original color directly.
    if (blurRadius <= 0.0) {
        return content.eval(fragCoord);
    }

    // Define Gaussian weights. Initializing by element to ensure maximum compatibility.
    float weights[5];
    weights[0] = 0.227027;
    weights[1] = 0.1945946;
    weights[2] = 0.1216216;
    weights[3] = 0.054054;
    weights[4] = 0.016216;

    // Calculate the step for one pixel, used for sampling the texture.
    vec2 texelStep = 1.0 / resolution;

    // Initialize the final color with the center pixel's color, applying the center weight.
    half3 finalColor = content.eval(fragCoord).rgb * weights[0];

    // --- Pass 1: Horizontal Blur ---
    // Loop to sample pixels to the left and right of the center.
    for (int i = 1; i < 5; ++i) {
        // Calculate the coordinates for the left and right sample points.
        vec2 leftCoord = fragCoord - vec2(texelStep.x * float(i) * blurRadius, 0.0);
        vec2 rightCoord = fragCoord + vec2(texelStep.x * float(i) * blurRadius, 0.0);

        // Read the colors from the sample points.
        half3 leftColor = content.eval(leftCoord).rgb;
        half3 rightColor = content.eval(rightCoord).rgb;

        // Add the sampled colors, multiplied by their corresponding weights, to the final color.
        finalColor += leftColor * weights[i];
        finalColor += rightColor * weights[i];
    }

    // --- Pass 2: Vertical Blur ---
    // Apply a vertical blur to the result of the horizontal blur.
    // NOTE: This is a simplified single-pass implementation. A more accurate Gaussian blur
    // usually requires two passes, but this approximation is efficient and looks good enough.
    for (int i = 1; i < 5; ++i) {
        // Calculate the coordinates for the up and down sample points.
        vec2 upCoord = fragCoord - vec2(0.0, texelStep.y * float(i) * blurRadius);
        vec2 downCoord = fragCoord + vec2(0.0, texelStep.y * float(i) * blurRadius);

        // Read the colors from the sample points.
        half3 upColor = content.eval(upCoord).rgb;
        half3 downColor = content.eval(downCoord).rgb;

        // Accumulate the colors.
        finalColor += upColor * weights[i];
        finalColor += downColor * weights[i];
    }

    // Return the final calculated blur color, with alpha at 1.0 (fully opaque).
    return half4(finalColor, 1.0);
}
