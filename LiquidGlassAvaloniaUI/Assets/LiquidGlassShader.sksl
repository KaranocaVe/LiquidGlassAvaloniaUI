// SKSL shader for a "liquid glass" distortion effect.
// Faithfully adapted from the JavaScript logic you provided.

uniform shader content;
uniform float radius;    // Controls the shape and intensity of the distortion. Mapped from 0-50 in C#.
uniform vec2 resolution;

/**
 * Calculates the signed distance from a point to a rounded rectangle.
 * @param p The coordinate to check, centered at (0,0).
 * @param b The half-dimensions of the rectangle.
 * @param r The corner radius.
 * @return The signed distance.
 */
float roundedRectSDF(vec2 p, vec2 b, float r) {
    vec2 q = abs(p) - b + r;
    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;
}

/**
 * The main entry point for the shader.
 * It receives pixel coordinates (fragCoord) and returns the final color.
 */
half4 main(vec2 fragCoord) {
    // Normalize coordinates to the [0, 1] range.
    vec2 uv = fragCoord / resolution;

    // Center the coordinates so (0,0) is the middle of the control.
    vec2 centeredUV = uv - 0.5;

    // --- Liquid Glass Logic ---
    // The parameters below are taken directly from your JavaScript example.

    // The half-dimensions of the distortion rectangle.
    vec2 rectHalfSize = vec2(0.3, 0.2);

    // The corner radius of the distortion shape.
    float cornerRadius = 0.6;

    // Calculate the distance from the current pixel to the edge of the rounded rectangle.
    float distanceToEdge = roundedRectSDF(centeredUV, rectHalfSize, cornerRadius);

    // Use smoothstep to create a displacement factor based on the distance.
    // This creates the "lens" effect.
    float displacement = smoothstep(0.8, 0.0, distanceToEdge - 0.15);
    float scaled = smoothstep(0.0, 1.0, displacement);

    // Calculate the new, distorted texture coordinates by applying the displacement.
    vec2 distortedUV = centeredUV * scaled;

    // Shift the coordinates back to the [0, 1] range for sampling.
    vec2 newUV = distortedUV + 0.5;

    // Sample the original content texture at the new, distorted coordinates.
    return content.eval(newUV * resolution);
}
